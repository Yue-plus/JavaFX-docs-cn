= Application Structure

== The MVVM Pattern
Model-View-ViewModel (MVVM) is a software architecture that separates UI controls (the View) from data access and business logic (the Model).  The separation helps larger applications during the maintenance phase.  With MVVM, View changes -- especially those that are purely cosmetic -- can be made without fear of introducing side effects.   Changes to the Model (usually less volatile than the View) can be applied more easily throughout the application because MVVM promotes reuse.

In between the View and the Model is the ViewModel.  The ViewModel mediates between the View and the Model, yet contains no references to the View.  This enables ViewModel sharing which is useful when two Views show similar data.

This article presents a simplified MVVM example.  An Employment Request Form submits several data elements to a back-end service.  This screenshot shows the application with the name, position, and annual salary data elements set.

image::images/app-structure/mvvmapp_screenshot.png[title="Employment Request Form"]

After entering the data and pressing Save, the Model object responds with a println().

[source,shell]
.Program Output
----
saving EmploymentRequest{name='Carl', position='Pizza Dough Thrower', annualSalary=30000.0}
----

If the Reset button is pressed after filling in the TextFields, the form is restored to its original values: empty name and position and an annualSalary of 0.

The Cancel button ends the application.

=== Structure

A simplified MVVM application is composed of the following types of classes

App::
	Main entry point
View::
	UI controls
Model::
	Function call to business logic and data access
ViewModel::
	Contains screen state and UI logic 
Domain object::
	UI-neutral transfer object
Converter::
	Helper class for ViewModel to Model communication

This UML shows the structure of the Employment Request Form.  The View class is EmploymentRequestView which contains the UI control objects like the Name `TextField`.  The ViewModel class is EmploymentRequestViewModel and contains JavaFX properties.  The Model class is EmploymentRequestModel with a single method for persisting the form.  EmploymentRequestConverter is a helper class.  EmploymentRequest is a POJO containing data fields.  MVVMApp is the main entry point, a JavaFX Application subclass.

image::images/app-structure/mvvmapp_uml.png[title="UML Class Model of Application"]

=== View

In MVVM, the View class is responsible for the UI controls and nothing else.  Event handlers attached to UI controls delegate immediately to the ViewModel.  JavaFX data binding updates the UI with Model changes.  In the Employment Request Form, three TextFields gather input from the user: tfName, tfPosition, tfAnnualSalary.  Three Buttons initiate operations on the application: btnSave, btnCancel, btnReset.  This is the beginning of the EmploymentRequestView class.

[source,java]
.EmploymentRequestView.class
----
public class EmploymentRequestView extends VBox {

    private GridPane gp = new GridPane();

    private TextField tfName = new TextField();
    private TextField tfPosition = new TextField();
    private TextField tfAnnualSalary = new TextField();

    private Button btnSave = new Button("Save");
    private Button btnCancel = new Button("Cancel");
    private Button btnReset = new Button("Reset");

    public EmploymentRequestView() {
        createView();
        bindViewModel();
    }
----

The View knows about the ViewModel and uses JavaFX binding to synchronize the UI with the ViewModel.  This demo treats the ViewModel as a prototype object, created when the View object is created.  Alternatively, the ViewModel can be a singleton or provided by CDI.  Each UI field is bound bi-directionally to the ViewModel.  As the UI changes -- say through entering a value in tfName -- the corresponding field in the ViewModel is updated.  The more complicated expression for the tfAnnualSalary field is needed to convert the String-based `TextField` into a DoubleProperty.

[source,java]
.EmploymentRequestView.class (cont.)
----
    private final EmploymentRequestViewModel viewModel =
            new EmploymentRequestViewModel();

    private void bindViewModel() {

        tfName.textProperty().bindBidirectional(viewModel.nameProperty());

        tfPosition.textProperty().bindBidirectional(viewModel.positionProperty());

        Bindings.bindBidirectional(
                tfAnnualSalary.textProperty(),
                viewModel.annualSalaryProperty(),
                new NumberStringConverter()
        );
    }
----

The UI in this demo is built in code.  The following createView() method handles the layout of the form and puts the core controls (such as tfName and btnSave) in containers.

[source,java]
.EmploymentRequestView.class (cont.)
----
    private void createView() {
        VBox gpwrap = new VBox();
        gpwrap.setAlignment( Pos.CENTER );

        gp.setPadding( new Insets(40) );
        gp.setVgap( 4 );
        gp.add(new Label("Name"), 0, 0);                  gp.add(tfName, 1, 0);
        gp.add(new Label("Desired Position"), 0, 1);      gp.add(tfPosition, 1, 1);
        gp.add(new Label("Current Annual Salary"), 0, 2); gp.add(tfAnnualSalary, 1, 2);

        final ColumnConstraints col = new ColumnConstraints();
        col.setPercentWidth( 50 );

        gp.getColumnConstraints().addAll( col, col );

        gpwrap.getChildren().add( gp );

        VBox.setVgrow( gpwrap, Priority.ALWAYS );

        btnSave.setOnAction( this::save );
        btnCancel.setOnAction( this::cancel );
        btnReset.setOnAction( this::reset );

        btnSave.setDefaultButton(true);

        ButtonBar buttonBar = new ButtonBar();
        buttonBar.setPadding( new Insets(20.0d) );
        ButtonBar.setButtonData(btnSave, ButtonBar.ButtonData.OK_DONE);
        ButtonBar.setButtonData(btnCancel, ButtonBar.ButtonData.CANCEL_CLOSE);
        ButtonBar.setButtonData(btnReset, ButtonBar.ButtonData.OTHER);

        buttonBar.getButtons().addAll( btnSave, btnCancel, btnReset );

        this.getChildren().addAll(
                gpwrap,
                new Separator(),
                buttonBar);
    }
----

The class ends with handlers for the Buttons.  These handlers delegate their actions to the ViewModel.

[source,java]
.EmploymentRequestView.class (cont.)
----
    private void save(ActionEvent evt) { viewModel.save(); }

    private void cancel(ActionEvent evt) {
        Platform.exit();
    }

    private void reset(ActionEvent evt) { viewModel.reset(); }
}
----

==== FXML and Scene Builder

In this example, the UI is built in code.  Scene Builder is a design-oriented alternative that can be more productive.  To convert this example to FXML, the product of Scene Builder, you would build the UI in the tool and annotate the fields and methods of the EmploymentRequestView class with @FXML.  See the following screenshot for how the demo looks in Scene Builder.  This is informational only and not part of the working demo.

image::images/app-structure/mvvmapp_sb.png[title="Scene Builder Could Also Implement the View"]

Notice that the right "half" of the UML diagram would not be changed by switching the View implementation from code to Scene Builder.  A sign of a good design is when alternative presentations can be supported easily.

=== ViewModel

The ViewModel is a layer that interacts with both the View and the Model.  In this simple presentation, the value of such a layer is limited; one could just unpack the TextFields into the Model in the `Button` handler.  As the UI becomes more complex, it is useful to have a plainer, more business-oriented object to work with.  While there is a one-to-one correspondence between View, Model, and ViewModel, that may not always be the case.  

Handling a many-to-many relationship is key for the ViewModel.  There may be many Views that working with the same Model element.  Multiple models may contribute to a single View.

This ViewModel looks like the domain object that will be presented later with one key difference: JavaFX Binding.  EmploymentRequestViewModel was bound to the EmploymentRequestView UI controls and the methods of EmploymentRequestViewModel will have access to all of the information within the save() method.  No extra marshaling of arguments is needed.

[source,java]
.EmploymentRequestViewModel.class
----
public class EmploymentRequestViewModel {

    private final StringProperty name = new SimpleStringProperty("");
    private final StringProperty position = new SimpleStringProperty("");
    private final DoubleProperty annualSalary = new SimpleDoubleProperty();

    private final EmploymentRequestConverter converter =
            new EmploymentRequestConverter();

    private final EmploymentRequestModel model = new EmploymentRequestModel();

    public String getName() {
        return name.get();
    }

    public StringProperty nameProperty() {
        return name;
    }

    public void setName(String name) {
        this.name.set(name);
    }

    public String getPosition() {
        return position.get();
    }

    public StringProperty positionProperty() {
        return position;
    }

    public void setPosition(String position) {
        this.position.set(position);
    }

    public double getAnnualSalary() {
        return annualSalary.get();
    }

    public DoubleProperty annualSalaryProperty() {
        return annualSalary;
    }

    public void setAnnualSalary(double annualSalary) {
        this.annualSalary.set(annualSalary);
    }

    public void save() {
        EmploymentRequest data = converter.toEmploymentRequest( this );
        model.save( data );
    }

    public void reset() {
        this.name.set("");
        this.position.set("");
        this.annualSalary.set(0.0d);
    }
}
----

Both the Converter and the Model have been added to this ViewModel as prototypes, meaning that they were created when the ViewModel was created.

==== Converter

The Converter is a class the translates between ViewModel and domain object.  In this app, there is a single toEmploymentRequest() method that creates an object from the ViewModel fields.

[source,java]
.EmploymentRequestConverter.class
----
public class EmploymentRequestConverter {

    public EmploymentRequest toEmploymentRequest(EmploymentRequestViewModel viewModel) {
        return new EmploymentRequest(
                viewModel.getName(),
                viewModel.getPosition(),
                viewModel.getAnnualSalary()
        );
    }
}
----

=== Model

Finally, the Model persists the information.  This Model example has a single mocked method which will verify that it receives the correct data for the save() operation.

[source,java]
.EmploymentRequestModel.class
----
public class EmploymentRequestModel {

    public void save(EmploymentRequest req) {
        System.out.println("saving " + req);
    }
}
----

This is the plain Java object used to transport data from the Model to the UI.

[source,java]
.EmploymentRequest.class
----
public class EmploymentRequest {

    private final String name;
    private final String position;
    private final Double annualSalary;

    public EmploymentRequest(String name,
                             String position,
                             Double annualSalary) {
        this.name = name;
        this.position = position;
        this.annualSalary = annualSalary;
    }

    public String getName() {
        return name;
    }

    public String getPosition() {
        return position;
    }

    public Double getAnnualSalary() {
        return annualSalary;
    }

    @Override
    public String toString() {
        return "EmploymentRequest{" +
                "name='" + name + '\'' +
                ", position='" + position + '\'' +
                ", annualSalary=" + annualSalary +
                '}';
    }
}
----

JavaFX provides developers with a powerful toolkit to build applications.  However, a design is still needed for an effective program.  MVVM is an architectural pattern that separates pure UI classes called Views from pure data classes called Models.  In the middle sits the ViewModel which relies heavily on the data binding in JavaFX.

=== Further Work

Sometimes, the View needs to know of a Model change.  Because MVVM dictates a one-way control flow -- View to ViewModel to Model and not the reverse -- a different mechanism than data binding is needed to make the ViewModel aware of Model changes.  A publishing / subscribing library can be used for this requirement which would broker the Model/ViewModel interaction.  ViewModel would receive a notification from the Model and the Model would not require a reference to the ViewModel object.

To read more about MVVM and JavaFX, check out the mvvmFX project.  The examples in that project provided the basis for this demonstration.

https://github.com/sialcasa/mvvmFX[mvvmFX]

=== Completed Code

The completed code in this example is available as a Gradle project here.  There are two examples in the JAR.  Run the class net.bekwam.bkcourse.mvvmapp.MVVMApp.

https://courses.bekwam.net/public_tutorials/source/bkcourse_mvvmapp_sources.zip[bkcourse_mvvmapp_sources.zip]

== Model Change with MVVM

The previous article showed how to add a JavaFX binding-based ViewModel to an application architecture.  However, the Model presented was a simple service call.  This expands on the prior concepts and adds

. Asynchrony,
. A `ProgressBar` and status `Label`, and
. Event broadcasting.

All operations taking more than a few milliseconds should be run on a separate `Thread`.  Something that runs quickly but involves IO or the network often turns into a performance problem as code moves to new computers and new network configurations.  A JavaFX `Task` is used to invoke the Model operation.  While this potentially long process is running, feedback is given to the user via a `ProgressBar` and `Label`.  The status `Label` conveys messages to the user from the JavaFX `Task`.

It is important that the Model not hold a reference to the ViewModel, so an event notification scheme is introduced.  The ViewModel listens for an EVENT_MODEL_UPDATE message from the Model.  Although this example uses only one ViewModel, this scheme makes it possible for more than one ViewModel to be aware of data changes from a single Model component.

=== Demo Program

The demo program in this section is a URL tester.  The user enters a URL in the `TextField` and presses the Submit `Button`.  If the HTTP request to the specified URL returns successfully, the HTTP response status code is displayed alongside the number of milliseconds the request took.  This screenshot shows a successful usage.

image::images/app-structure/modelchangeapp_screenshot_done.png[title="A Successful Run"]

The UI remains responsive throughout the request.  The responsiveness comes from the use of a JavaFX `Task` to run the URL retrieval on a background thread.  To make the user aware that processing is occurring, UI controls are tied to the properties of the `Task` through JavaFX binding.  This screenshot shows the feedback the user receives while the `Task` runs.

image::images/app-structure/modelchangeapp_screenshot_inprogress.png[title="In-Progress View of a Retrieval"]

When the Submit `Button` is pressed, a pair of controls are displayed: a `ProgressBar` and a `Label`.  Both controls are updated with information about the running background `Thread`.

Errors in the URL retrieval are handled by passing an alternate response object out of the Model.  In the successful case, the Model returned the HTTP status code and elapsed time.  In the error case, the Model sets a flag and returns an error message.  This screenshot shows an error dialog produced by the View in response to an error in the Model.  The errorMessage is from the message property of the thrown Exception.  If needed, additional fields like the Exception class name can be added.

image::images/app-structure/modelchangeapp_screenshot_err.png[title="Error Produced by Model"]

=== Design

The demo program consists of a single View / ViewModel / Model triple.  The View communicates with the ViewModel through JavaFX binding.  UI controls in the View are bound to JavaFX properties in the ViewModel.  Event handlers in the View delegate to methods in the ViewModel.  The ViewModel forms an asynchronous command which interacts with the Model.  The Model communicates indirectly with the ViewModel through a notification subsystem rather than an object reference.

This is a UML class model of the program.

image::images/app-structure/modelchangeapp_uml.png[title="Class Model of MVVM App"]

URLTestView is the View component and contains the UI controls.  The ViewModel contains properties for the domain -- url, last status code, last elapsed time -- and for the screen state such as urlTestTaskRunning.  Model contains a service call and works with a UI-neutral POJO URLTestObject.  Communication between the Model and the ViewModel is brokered through a Notifications singleton which has methods for publishing (for the Model) and subscribing (for the ViewModel).

This sequence diagram shows how the app wires itself up and the interactions that follow from a test operation.  

image::images/app-structure/modelchangeapp_uml_sd.png[title="Sequence Diagram of Successful Retrieval"]

After all the objects are created, the user initiates a test operation.  This results in a TestURLCommand object being created which is a JavaFX `Service`.  The service invokes a Model method testURL().  When testURL() finishes, it publishes a notification.  This notification triggers a call to the ViewModel to refresh itself which uses a second call to the Model.  The ViewModel refresh sets ViewModel JavaFX properties which automatically update the View.

=== View

The View is a StackPane containing the `TextField` that will gather the URL input and a Submit `Button`.  A `StackPane` was used so that the temporary status display could be added without breaking the centering of the main UI controls.  The `HBox` containing the status `Label` and `ProgressBar` is always present in the lower-left, but hidden unless a `Task` is running.

[source,java]
.URLTestView.class
----
public class URLTestView extends StackPane {

    private final URLTestViewModel testViewModel =
            new URLTestViewModel();

    public URLTestView() {

        Label lblURL = new Label("URL to Test");
        TextField tfURL = new TextField();
        Button btnTest = new Button("Test");
        Label lblStatus = new Label("");
        Label lblLoadTime = new Label("");
        HBox resultHBox = new HBox(lblStatus, lblLoadTime);
        resultHBox.setSpacing(10);

        VBox vbox = new VBox( lblURL, tfURL, btnTest, resultHBox );
        vbox.setPadding( new Insets(40) );
        vbox.setSpacing( 10 );
        vbox.setAlignment(Pos.CENTER_LEFT);

        Label lblTaskStatus = new Label("");
        ProgressBar pb = new ProgressBar();
        HBox statusHBox = new HBox(pb, lblTaskStatus);
        statusHBox.setSpacing(4);
        statusHBox.setPadding(new Insets(4));
        statusHBox.setMaxHeight( 20 );

        StackPane.setAlignment(statusHBox, Pos.BOTTOM_LEFT );

        this.getChildren().addAll( vbox, statusHBox );
----

The URLTestViewModel object is created in this class.  Alternatively, dependency injection can be used to distribute the same ViewModel object among other Views.

The URLTestView constructor continues with several binding expressions.  These link the UI controls to the ViewModel properties.

[source,java]
.URLTestView.class (cont.)
----
        lblStatus.textProperty().bind( testViewModel.statusCodeProperty() );
        lblLoadTime.textProperty().bind( testViewModel.loadTimeProperty() );
        testViewModel.urlProperty().bind( tfURL.textProperty() );

        statusHBox.visibleProperty().bind(testViewModel.urlTestTaskRunningProperty() );
        pb.progressProperty().bind( testViewModel.urlTestTaskProgressProperty() );
        lblTaskStatus.textProperty().bind( testViewModel.urlTestTaskMessageProperty());
----

The above statements register the UI controls for changes to the corresponding property in the ViewModel, except for tfURL.  tfURL uses a different binding direction since it is producing the value for the ViewModel.  In some cases, the binding may need to be bi-directional if a control can both be manipulated by the user and set from the ViewModel.

The action which initiates the testURL() operation is mapped to the Submit `Button`.

[source,java]
.URLTestView.class (cont.)
----
        btnTest.setOnAction( (evt) -> testViewModel.test() );
----

The URLTestView constructor finishes with a special ChangeListener binding to a ViewModel property. This is a notification that an error has occurred.  When the errorMessage property of the ViewModel is notified, the View displays a popup dialog.

[source,java]
.URLTestView.class (cont.)
----
        testViewModel.errorMessageProperty().addListener(
                (obs,ov,nv) -> {
                    if( nv != null && !nv.isEmpty() ) {
                        Alert alert = new Alert(
                                Alert.AlertType.ERROR, nv
                        );
                        alert.showAndWait();
                    }
                }
        );
----

=== ViewModel

URLTestView binds its UI controls to properties in URLTestViewModel.  This section of the class URLTestViewModel shows the properties used by the View and their corresponding access methods.  The test() method -- which was mapped to the Submit `Button` press event -- is also listed.  The object urlTestCommand will be presented later.

[source,java]
.URLTestViewModel.class
----
public class URLTestViewModel {

    // Data elements
    private final StringProperty url = new SimpleStringProperty("");
    private final StringProperty statusCode = new SimpleStringProperty("");
    private final StringProperty loadTime = new SimpleStringProperty("");

    // Status elements
    private final BooleanProperty wasError = new SimpleBooleanProperty(false);
    private final StringProperty errorMessage = new SimpleStringProperty("");

    public StringProperty urlProperty() { return url; }

    public StringProperty statusCodeProperty() { return statusCode; }

    public StringProperty loadTimeProperty() { return loadTime; }

    public StringProperty errorMessageProperty() { return errorMessage; }

    public ReadOnlyBooleanProperty urlTestTaskRunningProperty() {
        return urlTestCommand.runningProperty();  // presented later
    }

    public ReadOnlyStringProperty urlTestTaskMessageProperty() {
        return urlTestCommand.messageProperty();  // presented later
    }

    public ReadOnlyDoubleProperty urlTestTaskProgressProperty() {
        return urlTestCommand.progressProperty();  // presented later
    }

    public void test() {
       urlTestCommand.restart();  // presented later
    }
----

URLTestViewModel collaborates with two objects: URLTestModel and Notifications.  URLTestViewModel subscribes to a Notification in its constructor.  A URLTestViewModel method "update" will be called when the Notifications object posts an EVENT_MODEL_UPDATE.

[source,java]
.URLTestViewModel.class (cont.)
----
    private final URLTestModel urlTestModel = new URLTestModel();

    private final Notifications notifications = new Notifications();

    public URLTestViewModel() {
        notifications.subscribe(Notifications.EVENT_MODEL_UPDATE,
                                this,
                                this::update);  // presented later
    }
----

==== Command

urlTestCommand is a JavaFX `Service` object.  As a part of the URLTestViewModel class, urlTestCommand has access to the url property which provides a parameter for the call to the Model object.  urlTestCommand also uses the URLTestModel member to initiate the call to test the URL.

[source,java]
.URLTestViewModel.class (cont.)
----
    private final Service<Void> urlTestCommand = new Service<Void>() {
        @Override
        protected Task<Void> createTask() {
            return new Task<Void>() {
                @Override
                protected Void call() throws Exception {
                    updateProgress(0.1d, 1.0d);
                    updateMessage("Testing url " + url.get());
                    urlTestModel.testURL( url.get() );
                    return null;
                }
                protected void failed() {
                    getException().printStackTrace();  // just in case
                }
            };
        }
    };
----

A JavaFX `Service` was used since the `Service` objects needs to always exist for binding purposes.  URLTestView binds its `ProgressBar`, status `Label`, and container controls to the URLTestViewModel object which will be available for the life of the app.  Shown earlier, the URLTestViewModel properties delegate to the `Service` object.  A `Task` is a one-shot invocation and using that would not work for multiple test() invocations.

[sidebar]
.Asynchrony
--
The design in this article puts the burden of asynchronous processing on the ViewModel.  This provides direct feedback to View controls using JavaFX binding.  An alternative approach is to use a general event emitting scheme to listen for task starting, task ending, progress, and message events.  This would support breaking out the urlTestCommand `Service` subclass into a separate code module.
--

The presentation of the URLTestViewModel class concludes with the update() method.  This method issues a call to the Model, unpacks the results, and updates the ViewModel properties.  Recall that the View has bound to these properties and will automatically be updated (there is no similar update() method in the View.

[source,java]
.URLTestViewModel.class (cont.)
----
    private void update(String event) {

        urlTestModel.getUrlTestObject().ifPresent(

            (testObject) -> {

                wasError.set( testObject.getWasError() );

                if( !testObject.getWasError() ) {

                    statusCode.set(
                            "Status code: " +
                            String.valueOf(testObject.getStatusCode())
                    );

                    loadTime.set(
                            String.valueOf(testObject.getLoadTime()) +
                                    " ms"
                    );

                    errorMessage.set(testObject.getErrorMessage());
                } else {
                    statusCode.set("");  // use empty TextField, not 0
                    loadTime.set("");  // use empty TextField, not 0
                    errorMessage.set( testObject.getErrorMessage() );
                }
            });
    }
----

=== Model

URLTestModel is presented in its entirety below.  URLTestModel maintains a copy of a domain object.  Upon initialization, this object is empty so an `Optional` is used.  A getter is provided for ViewModels.  The testURL() method issues an HTTP GET call and records the results in the URLTestObject member.  If the HTTP GET call is successful, the URLTestObject will contain the status code (probably 200) and an elapsed time.  If unsuccessful, the URLTestObject will set a convenient wasError flag and an errorMessage.

When the Model has retrieved the contents at the URL or generated an error, the publish() method of the Notifications object is invoked.  This prompts URLTestViewModel to update itself, but in a decoupled fashion.  It is important to note that URLTestModel does not hold a reference to a URLTestViewModel object.

[source,java]
.URLTestModel.class
----
public class URLTestModel {

    private final Notifications notifications =
            new Notifications();

    private Optional<URLTestObject> urlTestObject =
            Optional.empty();

    public Optional<URLTestObject> getUrlTestObject() {
        return urlTestObject;
    }

    public Optional<URLTestObject> testURL(String url) {

        try {
            long startTimeMillis = System.currentTimeMillis();
            HttpURLConnection urlConnection =
                    (HttpURLConnection) new URL(url).openConnection();
            try (
                    InputStream is = urlConnection.getInputStream();
            ) {
                while (is.read() != -1) {
                }
            }
            long endTimeMillis = System.currentTimeMillis();

            URLTestObject uto = new URLTestObject(
                    urlConnection.getResponseCode(),
                    (int) (endTimeMillis - startTimeMillis)
            );

            urlTestObject = Optional.of(uto);

        } catch(Exception exc) {
            URLTestObject uto = new URLTestObject(exc.getMessage());
            urlTestObject = Optional.of(uto);
        }

        notifications.publish(Notifications.EVENT_MODEL_UPDATE);

        return urlTestObject;
    }
}
----

URLTestModel also does not attempt to bind to URLTestViewModel using JavaFX.  Since the asynchrony is handled at the ViewModel layer, the Model is free to operate off of the JavaFX Thread.  Attempting to double-bind (View->ViewModel->Model) would result in an application threading error if binding were used.  Wrapped in a Platform.runLater(), a double-bind does not violate the prescribed dependency order -- ViewModel already holds a reference to Model -- but might result in an inconsistent update.

This POJO is the domain object used by the Model.  As a POJO, this is can be maintained in a commons library and shared among non-UI components like a RESTful web services project.

[source,java]
.URLTestObject.class
----
public class URLTestObject {

    private final Integer statusCode;
    private final Integer loadTime;
    private final Boolean wasError;
    private final String errorMessage;

    public URLTestObject(Integer statusCode,
                         Integer loadTime) {
        this.statusCode = statusCode;
        this.loadTime = loadTime;
        wasError = false;
        errorMessage = "";
    }

    public URLTestObject(String errorMessage) {
        this.statusCode = null;
        this.loadTime = null;
        wasError = true;
        this.errorMessage = errorMessage;
    }

    public Integer getLoadTime() {
        return loadTime;
    }

    public Integer getStatusCode() {
        return statusCode;
    }

    public Boolean getWasError() {
        return wasError;
    }

    public String getErrorMessage() {
        return errorMessage;
    }
}
----

=== Notifications

This class is a lightweight pub/sub implementation.  Event types are registered as String constants at the top of the file.  Subscribers are identified by their class hashCode.  All the published events will run on the JavaFX Thread.

[source,java]
.Notifications.class
----
public class Notifications {

    public final static String EVENT_MODEL_UPDATE = "modelUpdate";

    private final Map<String, List<SubscriberObject>> subscribers = new LinkedHashMap<>();

    private static Notifications instance = new Notifications();

    public void publish(String event) {

        Platform.runLater( () -> {
            List<SubscriberObject> subscriberList = instance.subscribers.get(event);

            if (subscriberList != null) {

                subscriberList.forEach(
                    subscriberObject -> subscriberObject.getCb().accept(event)
                    );

                // event ends after last subscriber gets callback
            }
        } );
    }

    public void subscribe(String event, Object subscriber, Consumer<String> cb) {

        if( !instance.subscribers.containsKey(event) ) {
            List<SubscriberObject> slist = new ArrayList<>();
            instance.subscribers.put( event, slist );
        }

        List<SubscriberObject> subscriberList = instance.subscribers.get( event );

        subscriberList.add( new SubscriberObject(subscriber, cb) );
    }

    public void unsubscribe(String event, Object subscriber) {

        List<SubscriberObject> subscriberList = instance.subscribers.get( event );

        if (subscriberList == null) {
            subscriberList.remove( subscriber );
        }
    }

    static class SubscriberObject {

        private final Object subscriber;
        private final Consumer<String> cb;

        public SubscriberObject(Object subscriber,
                                Consumer<String> cb) {
            this.subscriber = subscriber;
            this.cb = cb;
        }

        public Object getSubscriber() {
            return subscriber;
        }

        public Consumer<String> getCb() {
            return cb;
        }

        @Override
        public int hashCode() {
            return subscriber.hashCode();
        }

        @Override
        public boolean equals(Object obj) {
            return subscriber.equals(obj);
        }
    }
}
----

Notifications is a singleton so that any class -- both URLTestViewModel and URLTestModel in this case -- will subscribe to and publish to the right instance.

=== App

For completeness, the Application subclass is listed below.

[source,java]
.ModelChangeApp.class
----
public class ModelChangeApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        Scene scene = new Scene(new URLTestView());

        primaryStage.setTitle("Model Change App");
        primaryStage.setScene( scene );
        primaryStage.setWidth(568);
        primaryStage.setHeight(320);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

MVVM is an architecture that separates the View from the Model.  Unlike other architectures, this separation includes a specific dependency graph: View depends on ViewModel depends on Model.  All three component types collaborate, but in cases where data moves in the opposite direction of the dependency graph, the communication is indirect.  In this example, the indirect communication was provided by JavaFX binding and a special Notifications class.  By keeping the Model and ViewModel free of View dependencies, the MVVM architecture fosters reuse.  URLTestModel can be used by other ViewModels and URLTestViewModel can be used by other Views.

=== Completed Code

The completed code in this example is available as a Gradle project here.  There are two examples in the JAR.  Run the class net.bekwam.bkcourse.modelchangeapp.ModelChangeApp.

https://courses.bekwam.net/public_tutorials/source/bkcourse_mvvmapp_sources.zip[bkcourse_mvvmapp_sources.zip]

== The Dialog Class
The `Dialog` class was a surprising latecomer to the JavaFX library.  The Dialog class displays a customized supporting window to execute an operation or to retrieve additional information.  The subclass `Alert` is also available and is better suited for focused interactions like a confirmation, retrieving a text value (`TextInputDialog`), or a selected item (`ChoiceDialog`).

This section will demonstrate the Dialog class built on a domain object, ConnectionInfo.  A main screen is displayed with a `TextField` for a database URL.  Pressing the set `Button` displays the Dialog.  If the user fills in values and presses the Save Button, the Dialog is dismissed and the ConnectionInfo domain object is returned to the caller.  If the Cancel Button is pressed, an empty `Optional` is returned.

This screenshot shows the app when it starts up.  The DB URL field is empty.

image::images/app-structure/dialogapp_main_empty.png[title="DialogApp At Startup"]

Pressing the Set Button displays the Dialog.  The user has filled in values for host, username, and password.

image::images/app-structure/dialogapp_dialog_filledin.png[title="Gathering Values"] 

Closing the Dialog via the Save Button forms a ConnectionInfo object that is returned to the caller.  This value is formed into a `String` and put into the TextField.

image::images/app-structure/dialogapp_main_filledin.png[title="Values Retrieved"]

The reverse interaction is also supported in this example.  If the user types in a well-formed URL, that URL will be parsed and displayed in the Dialog.  URL String validation has been left off.  An invalid URL String will result in an empty Dialog.

=== App

The JavaFX `Application` subclass adds UI controls for the DB URL TextField and Save Button.

[source,java]
.DialogApp.java
----
public class DialogApp extends Application {

    private final TextField dbURL = new TextField();

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label label = new Label("DB URL");
        dbURL.setPrefWidth(400.0d );
        Button btn = new Button("Set");
        btn.setOnAction( this::showSetDialog );

        VBox vbox = new VBox(label, dbURL, btn );
        vbox.setSpacing( 10.0d );
        vbox.setPadding( new Insets(40.0d) );

        Scene scene = new Scene( vbox );

        primaryStage.setTitle("Dialog App");
        primaryStage.setScene( scene );
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
----

showSetDialog() is a method reference that initializes a ConnectionInfo object, displays the Dialog, and retrieves a value if set by the user.

[source,java]
.DialogApp.java
----
    private void showSetDialog(ActionEvent evt) {

        ConnectionInfo fromURL = ciConverter.fromString( dbURL.getText() );

        ConnectionDialog dialog = new ConnectionDialog(fromURL);

        Optional<ConnectionInfo> ci = dialog.showAndWait();

        ci.ifPresent( c -> dbURL.setText(
                ciConverter.toString(c)
            )
        );
    }
----

The app is using a JavaFX `StringConverter` to encapsulate the code behind forming a String from the set of fields of the ConnectionInfo object.  The StringConverter is stored as a field in the Application subclass.

[source,java]
.DialogApp.java
----
    private final ConnectionInfoStringConverter ciConverter =
            new ConnectionInfoStringConverter();


   class ConnectionInfoStringConverter extends StringConverter<ConnectionInfo> {

        private final String format = "%s@%s:%s";

        @Override
        public String toString(ConnectionInfo c) {
            return String.format( format, c.getUsername(), c.getPassword(), c.getHost() );
        }

        @Override
        public ConnectionInfo fromString(String s) {

            if( s != null && s.contains("@") && s.contains(":") ) {
                String[] toks = s.split("@");
                String username = toks[0];
                String[] secondPart = toks[1].split(":");
                String password = secondPart[0];
                String host = secondPart[1];
                ConnectionInfo ci = new ConnectionInfo(
                        username, password, host
                );
                return ci;
            }

            return null;
        }
    }
----

=== Dialog

The Dialog subclass adds UI controls to the DialogPane field in the constructor.  Notice the lack of explicit `ActionEvent` handlers.  When using Dialog or Alert, ButtonType and ButtonData are preferred over raw Button objects.  These higher-order objects make the app UI more consistent because the Button placement, labeling, and behavior is handed in the Dialog abstraction.

The subclass contains a type parameter to the ConnectionInfo domain object.

[source,java]
.ConnectionDialog.java
----
public class ConnectionDialog extends Dialog<ConnectionInfo> {

    private final TextField tfHost = new TextField();
    private final TextField tfUser = new TextField();
    private final TextField tfPassword = new TextField();

    public ConnectionDialog(ConnectionInfo initialData) {

        Label hostLabel = new Label("Host");
        Label userLabel = new Label("User");
        Label passwordLabel = new Label("Password");

        VBox vbox = new VBox(
                hostLabel, tfHost,
                userLabel, tfUser,
                passwordLabel, tfPassword
        );

        vbox.setSpacing( 10.0d );
        vbox.setPadding( new Insets(40.0d) );

        DialogPane dp = getDialogPane();

        setTitle( "Connection Info" );
        setResultConverter( this::formResult );

        ButtonType bt = new ButtonType("Save", ButtonBar.ButtonData.OK_DONE);
        dp.getButtonTypes().addAll( bt, ButtonType.CANCEL );
        dp.setContent( vbox );

        init( initialData );
    }
----

The init() method sets the Dialog UI controls based on the ConnectionInfo fields.

[source,java]
.ConnectionDialog.java
----
    private void init(ConnectionInfo ci) {
        if (ci != null) {
            tfHost.setText( ci.getHost() );
            tfUser.setText( ci.getUsername() );
            tfPassword.setText( ci.getPassword() );
        }
    }
----

The setResultConverter() is the mechanism by which the Dialog will communicate its domain object back to the caller.  The converter is a callback that returns a ConnectionInfo object if one can be formed from the input.  In this case, the Dialog makes a decision to send back an object if the Save Button was pressed.  Validating the Dialog fields can be performed as part of the TextField themselves or as an EventFilter attached to the Save Button.

[source,java]
.ConnectionDialog.java
----
    private ConnectionInfo formResult(ButtonType bt) {
        ConnectionInfo retval = null;
        if( bt.getButtonData() == ButtonBar.ButtonData.OK_DONE ) {
            retval = new ConnectionInfo(
                    tfHost.getText(), tfUser.getText(), tfPassword.getText()
            );
        }
        return retval;
    }
----

=== Domain Object

The domain object ConnectionInfo is an immutable POJO.

[source,java]
.ConnectionInfo.java
----
public class ConnectionInfo {

    private final String host;
    private final String username;
    private final String password;

    public ConnectionInfo(String host,
                          String username,
                          String password) {
        this.host = host;
        this.username = username;
        this.password = password;
    }

    public String getHost() {
        return host;
    }

    public String getUsername() {
        return username;
    }

    public String getPassword() {
        return password;
    }
}
----

The JavaFX Dialog and Alert subclass are windows that provide a simpler interface and a more consistent style than a raw Stage.  Alert is the preferred class when a warning, confirmation, or single value needs to be retrieved from the user. Dialog is used for complex, but contained, interactions with the user.  This example showed how a main Stage can keep its view simple by delegating the retrieval of detailed information to a Dialog.  Dialog -- when paired with a type parameter -- improves information hiding in an app by turning a showAndWait() call into a function that returns a value.

=== Source

The complete source code and Gradle project can be found at the link below.

https://courses.bekwam.net/public_tutorials/source/bkcourse_dialogapp_sources.zip[DialogApp Source Zip]

